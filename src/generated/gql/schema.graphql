schema {
  query: query_root
  subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
  """
  measured in seconds
  """
  ttl: Int! = 60

  """
  refresh the cache entry
  """
  refresh: Boolean! = false
) on QUERY

scalar _text

"""
Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'.
"""
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"""
columns and relationships of "Candidate"
"""
type Candidate {
  banner_url: String
  blurb: String
  community_plan: String
  created_at: timestamp!
  discord_name: String
  email: String
  id: Int!
  introduction: String
  location: String
  logo: String
  name: String
  reward_plan: String
  server_endpoint: String
  server_health_endpoint: String
  share_card_image: String
  social_media: _text
  team: String
  tech_setup: String
  temp_eth_address: String
  updated_at: timestamp!
  website: String
}

"""
aggregated selection of "Candidate"
"""
type Candidate_aggregate {
  aggregate: Candidate_aggregate_fields
  nodes: [Candidate!]!
}

"""
aggregate fields of "Candidate"
"""
type Candidate_aggregate_fields {
  avg: Candidate_avg_fields
  count(columns: [Candidate_select_column!], distinct: Boolean): Int!
  max: Candidate_max_fields
  min: Candidate_min_fields
  stddev: Candidate_stddev_fields
  stddev_pop: Candidate_stddev_pop_fields
  stddev_samp: Candidate_stddev_samp_fields
  sum: Candidate_sum_fields
  var_pop: Candidate_var_pop_fields
  var_samp: Candidate_var_samp_fields
  variance: Candidate_variance_fields
}

"""
aggregate avg on columns
"""
type Candidate_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "Candidate". All fields are combined with a logical 'AND'.
"""
input Candidate_bool_exp {
  _and: [Candidate_bool_exp!]
  _not: Candidate_bool_exp
  _or: [Candidate_bool_exp!]
  banner_url: String_comparison_exp
  blurb: String_comparison_exp
  community_plan: String_comparison_exp
  created_at: timestamp_comparison_exp
  discord_name: String_comparison_exp
  email: String_comparison_exp
  id: Int_comparison_exp
  introduction: String_comparison_exp
  location: String_comparison_exp
  logo: String_comparison_exp
  name: String_comparison_exp
  reward_plan: String_comparison_exp
  server_endpoint: String_comparison_exp
  server_health_endpoint: String_comparison_exp
  share_card_image: String_comparison_exp
  social_media: _text_comparison_exp
  team: String_comparison_exp
  tech_setup: String_comparison_exp
  temp_eth_address: String_comparison_exp
  updated_at: timestamp_comparison_exp
  website: String_comparison_exp
}

"""
aggregate max on columns
"""
type Candidate_max_fields {
  banner_url: String
  blurb: String
  community_plan: String
  created_at: timestamp
  discord_name: String
  email: String
  id: Int
  introduction: String
  location: String
  logo: String
  name: String
  reward_plan: String
  server_endpoint: String
  server_health_endpoint: String
  share_card_image: String
  team: String
  tech_setup: String
  temp_eth_address: String
  updated_at: timestamp
  website: String
}

"""
aggregate min on columns
"""
type Candidate_min_fields {
  banner_url: String
  blurb: String
  community_plan: String
  created_at: timestamp
  discord_name: String
  email: String
  id: Int
  introduction: String
  location: String
  logo: String
  name: String
  reward_plan: String
  server_endpoint: String
  server_health_endpoint: String
  share_card_image: String
  team: String
  tech_setup: String
  temp_eth_address: String
  updated_at: timestamp
  website: String
}

"""
Ordering options when selecting data from "Candidate".
"""
input Candidate_order_by {
  banner_url: order_by
  blurb: order_by
  community_plan: order_by
  created_at: order_by
  discord_name: order_by
  email: order_by
  id: order_by
  introduction: order_by
  location: order_by
  logo: order_by
  name: order_by
  reward_plan: order_by
  server_endpoint: order_by
  server_health_endpoint: order_by
  share_card_image: order_by
  social_media: order_by
  team: order_by
  tech_setup: order_by
  temp_eth_address: order_by
  updated_at: order_by
  website: order_by
}

"""
select columns of table "Candidate"
"""
enum Candidate_select_column {
  """
  column name
  """
  banner_url

  """
  column name
  """
  blurb

  """
  column name
  """
  community_plan

  """
  column name
  """
  created_at

  """
  column name
  """
  discord_name

  """
  column name
  """
  email

  """
  column name
  """
  id

  """
  column name
  """
  introduction

  """
  column name
  """
  location

  """
  column name
  """
  logo

  """
  column name
  """
  name

  """
  column name
  """
  reward_plan

  """
  column name
  """
  server_endpoint

  """
  column name
  """
  server_health_endpoint

  """
  column name
  """
  share_card_image

  """
  column name
  """
  social_media

  """
  column name
  """
  team

  """
  column name
  """
  tech_setup

  """
  column name
  """
  temp_eth_address

  """
  column name
  """
  updated_at

  """
  column name
  """
  website
}

"""
aggregate stddev on columns
"""
type Candidate_stddev_fields {
  id: Float
}

"""
aggregate stddev_pop on columns
"""
type Candidate_stddev_pop_fields {
  id: Float
}

"""
aggregate stddev_samp on columns
"""
type Candidate_stddev_samp_fields {
  id: Float
}

"""
aggregate sum on columns
"""
type Candidate_sum_fields {
  id: Int
}

"""
aggregate var_pop on columns
"""
type Candidate_var_pop_fields {
  id: Float
}

"""
aggregate var_samp on columns
"""
type Candidate_var_samp_fields {
  id: Float
}

"""
aggregate variance on columns
"""
type Candidate_variance_fields {
  id: Float
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "KV"
"""
type KV {
  id: Int!
  key: String!
  value: String!
}

"""
aggregated selection of "KV"
"""
type KV_aggregate {
  aggregate: KV_aggregate_fields
  nodes: [KV!]!
}

"""
aggregate fields of "KV"
"""
type KV_aggregate_fields {
  avg: KV_avg_fields
  count(columns: [KV_select_column!], distinct: Boolean): Int!
  max: KV_max_fields
  min: KV_min_fields
  stddev: KV_stddev_fields
  stddev_pop: KV_stddev_pop_fields
  stddev_samp: KV_stddev_samp_fields
  sum: KV_sum_fields
  var_pop: KV_var_pop_fields
  var_samp: KV_var_samp_fields
  variance: KV_variance_fields
}

"""
aggregate avg on columns
"""
type KV_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "KV". All fields are combined with a logical 'AND'.
"""
input KV_bool_exp {
  _and: [KV_bool_exp!]
  _not: KV_bool_exp
  _or: [KV_bool_exp!]
  id: Int_comparison_exp
  key: String_comparison_exp
  value: String_comparison_exp
}

"""
aggregate max on columns
"""
type KV_max_fields {
  id: Int
  key: String
  value: String
}

"""
aggregate min on columns
"""
type KV_min_fields {
  id: Int
  key: String
  value: String
}

"""
Ordering options when selecting data from "KV".
"""
input KV_order_by {
  id: order_by
  key: order_by
  value: order_by
}

"""
select columns of table "KV"
"""
enum KV_select_column {
  """
  column name
  """
  id

  """
  column name
  """
  key

  """
  column name
  """
  value
}

"""
aggregate stddev on columns
"""
type KV_stddev_fields {
  id: Float
}

"""
aggregate stddev_pop on columns
"""
type KV_stddev_pop_fields {
  id: Float
}

"""
aggregate stddev_samp on columns
"""
type KV_stddev_samp_fields {
  id: Float
}

"""
aggregate sum on columns
"""
type KV_sum_fields {
  id: Int
}

"""
aggregate var_pop on columns
"""
type KV_var_pop_fields {
  id: Float
}

"""
aggregate var_samp on columns
"""
type KV_var_samp_fields {
  id: Float
}

"""
aggregate variance on columns
"""
type KV_variance_fields {
  id: Float
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc

  """
  in ascending order, nulls first
  """
  asc_nulls_first

  """
  in ascending order, nulls last
  """
  asc_nulls_last

  """
  in descending order, nulls first
  """
  desc

  """
  in descending order, nulls first
  """
  desc_nulls_first

  """
  in descending order, nulls last
  """
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "Candidate"
  """
  Candidate(
    """
    distinct select on columns
    """
    distinct_on: [Candidate_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Candidate_order_by!]

    """
    filter the rows returned
    """
    where: Candidate_bool_exp
  ): [Candidate!]!

  """
  fetch aggregated fields from the table: "Candidate"
  """
  Candidate_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [Candidate_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Candidate_order_by!]

    """
    filter the rows returned
    """
    where: Candidate_bool_exp
  ): Candidate_aggregate!

  """
  fetch data from the table: "Candidate" using primary key columns
  """
  Candidate_by_pk(id: Int!): Candidate

  """
  fetch data from the table: "KV"
  """
  KV(
    """
    distinct select on columns
    """
    distinct_on: [KV_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [KV_order_by!]

    """
    filter the rows returned
    """
    where: KV_bool_exp
  ): [KV!]!

  """
  fetch aggregated fields from the table: "KV"
  """
  KV_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [KV_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [KV_order_by!]

    """
    filter the rows returned
    """
    where: KV_bool_exp
  ): KV_aggregate!

  """
  fetch data from the table: "KV" using primary key columns
  """
  KV_by_pk(id: Int!): KV

  """
  fetch data from the table: "RewardRecord"
  """
  RewardRecord(
    """
    distinct select on columns
    """
    distinct_on: [RewardRecord_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [RewardRecord_order_by!]

    """
    filter the rows returned
    """
    where: RewardRecord_bool_exp
  ): [RewardRecord!]!

  """
  fetch aggregated fields from the table: "RewardRecord"
  """
  RewardRecord_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [RewardRecord_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [RewardRecord_order_by!]

    """
    filter the rows returned
    """
    where: RewardRecord_bool_exp
  ): RewardRecord_aggregate!

  """
  fetch data from the table: "RewardRecord" using primary key columns
  """
  RewardRecord_by_pk(id: Int!): RewardRecord
}

"""
columns and relationships of "RewardRecord"
"""
type RewardRecord {
  address: String!
  apy: numeric
  burndrop_reward: numeric
  burndrop_reward_delta: numeric
  date: timestamp!
  hermes_reward: numeric
  hermes_reward_delta: numeric
  id: Int!
  staking: numeric
  total_reward: numeric
  total_reward_delta: numeric
}

"""
aggregated selection of "RewardRecord"
"""
type RewardRecord_aggregate {
  aggregate: RewardRecord_aggregate_fields
  nodes: [RewardRecord!]!
}

"""
aggregate fields of "RewardRecord"
"""
type RewardRecord_aggregate_fields {
  avg: RewardRecord_avg_fields
  count(columns: [RewardRecord_select_column!], distinct: Boolean): Int!
  max: RewardRecord_max_fields
  min: RewardRecord_min_fields
  stddev: RewardRecord_stddev_fields
  stddev_pop: RewardRecord_stddev_pop_fields
  stddev_samp: RewardRecord_stddev_samp_fields
  sum: RewardRecord_sum_fields
  var_pop: RewardRecord_var_pop_fields
  var_samp: RewardRecord_var_samp_fields
  variance: RewardRecord_variance_fields
}

"""
aggregate avg on columns
"""
type RewardRecord_avg_fields {
  apy: Float
  burndrop_reward: Float
  burndrop_reward_delta: Float
  hermes_reward: Float
  hermes_reward_delta: Float
  id: Float
  staking: Float
  total_reward: Float
  total_reward_delta: Float
}

"""
Boolean expression to filter rows from the table "RewardRecord". All fields are combined with a logical 'AND'.
"""
input RewardRecord_bool_exp {
  _and: [RewardRecord_bool_exp!]
  _not: RewardRecord_bool_exp
  _or: [RewardRecord_bool_exp!]
  address: String_comparison_exp
  apy: numeric_comparison_exp
  burndrop_reward: numeric_comparison_exp
  burndrop_reward_delta: numeric_comparison_exp
  date: timestamp_comparison_exp
  hermes_reward: numeric_comparison_exp
  hermes_reward_delta: numeric_comparison_exp
  id: Int_comparison_exp
  staking: numeric_comparison_exp
  total_reward: numeric_comparison_exp
  total_reward_delta: numeric_comparison_exp
}

"""
aggregate max on columns
"""
type RewardRecord_max_fields {
  address: String
  apy: numeric
  burndrop_reward: numeric
  burndrop_reward_delta: numeric
  date: timestamp
  hermes_reward: numeric
  hermes_reward_delta: numeric
  id: Int
  staking: numeric
  total_reward: numeric
  total_reward_delta: numeric
}

"""
aggregate min on columns
"""
type RewardRecord_min_fields {
  address: String
  apy: numeric
  burndrop_reward: numeric
  burndrop_reward_delta: numeric
  date: timestamp
  hermes_reward: numeric
  hermes_reward_delta: numeric
  id: Int
  staking: numeric
  total_reward: numeric
  total_reward_delta: numeric
}

"""
Ordering options when selecting data from "RewardRecord".
"""
input RewardRecord_order_by {
  address: order_by
  apy: order_by
  burndrop_reward: order_by
  burndrop_reward_delta: order_by
  date: order_by
  hermes_reward: order_by
  hermes_reward_delta: order_by
  id: order_by
  staking: order_by
  total_reward: order_by
  total_reward_delta: order_by
}

"""
select columns of table "RewardRecord"
"""
enum RewardRecord_select_column {
  """
  column name
  """
  address

  """
  column name
  """
  apy

  """
  column name
  """
  burndrop_reward

  """
  column name
  """
  burndrop_reward_delta

  """
  column name
  """
  date

  """
  column name
  """
  hermes_reward

  """
  column name
  """
  hermes_reward_delta

  """
  column name
  """
  id

  """
  column name
  """
  staking

  """
  column name
  """
  total_reward

  """
  column name
  """
  total_reward_delta
}

"""
aggregate stddev on columns
"""
type RewardRecord_stddev_fields {
  apy: Float
  burndrop_reward: Float
  burndrop_reward_delta: Float
  hermes_reward: Float
  hermes_reward_delta: Float
  id: Float
  staking: Float
  total_reward: Float
  total_reward_delta: Float
}

"""
aggregate stddev_pop on columns
"""
type RewardRecord_stddev_pop_fields {
  apy: Float
  burndrop_reward: Float
  burndrop_reward_delta: Float
  hermes_reward: Float
  hermes_reward_delta: Float
  id: Float
  staking: Float
  total_reward: Float
  total_reward_delta: Float
}

"""
aggregate stddev_samp on columns
"""
type RewardRecord_stddev_samp_fields {
  apy: Float
  burndrop_reward: Float
  burndrop_reward_delta: Float
  hermes_reward: Float
  hermes_reward_delta: Float
  id: Float
  staking: Float
  total_reward: Float
  total_reward_delta: Float
}

"""
aggregate sum on columns
"""
type RewardRecord_sum_fields {
  apy: numeric
  burndrop_reward: numeric
  burndrop_reward_delta: numeric
  hermes_reward: numeric
  hermes_reward_delta: numeric
  id: Int
  staking: numeric
  total_reward: numeric
  total_reward_delta: numeric
}

"""
aggregate var_pop on columns
"""
type RewardRecord_var_pop_fields {
  apy: Float
  burndrop_reward: Float
  burndrop_reward_delta: Float
  hermes_reward: Float
  hermes_reward_delta: Float
  id: Float
  staking: Float
  total_reward: Float
  total_reward_delta: Float
}

"""
aggregate var_samp on columns
"""
type RewardRecord_var_samp_fields {
  apy: Float
  burndrop_reward: Float
  burndrop_reward_delta: Float
  hermes_reward: Float
  hermes_reward_delta: Float
  id: Float
  staking: Float
  total_reward: Float
  total_reward_delta: Float
}

"""
aggregate variance on columns
"""
type RewardRecord_variance_fields {
  apy: Float
  burndrop_reward: Float
  burndrop_reward_delta: Float
  hermes_reward: Float
  hermes_reward_delta: Float
  id: Float
  staking: Float
  total_reward: Float
  total_reward_delta: Float
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """
  does the column NOT match the given pattern
  """
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "Candidate"
  """
  Candidate(
    """
    distinct select on columns
    """
    distinct_on: [Candidate_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Candidate_order_by!]

    """
    filter the rows returned
    """
    where: Candidate_bool_exp
  ): [Candidate!]!

  """
  fetch aggregated fields from the table: "Candidate"
  """
  Candidate_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [Candidate_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [Candidate_order_by!]

    """
    filter the rows returned
    """
    where: Candidate_bool_exp
  ): Candidate_aggregate!

  """
  fetch data from the table: "Candidate" using primary key columns
  """
  Candidate_by_pk(id: Int!): Candidate

  """
  fetch data from the table: "KV"
  """
  KV(
    """
    distinct select on columns
    """
    distinct_on: [KV_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [KV_order_by!]

    """
    filter the rows returned
    """
    where: KV_bool_exp
  ): [KV!]!

  """
  fetch aggregated fields from the table: "KV"
  """
  KV_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [KV_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [KV_order_by!]

    """
    filter the rows returned
    """
    where: KV_bool_exp
  ): KV_aggregate!

  """
  fetch data from the table: "KV" using primary key columns
  """
  KV_by_pk(id: Int!): KV

  """
  fetch data from the table: "RewardRecord"
  """
  RewardRecord(
    """
    distinct select on columns
    """
    distinct_on: [RewardRecord_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [RewardRecord_order_by!]

    """
    filter the rows returned
    """
    where: RewardRecord_bool_exp
  ): [RewardRecord!]!

  """
  fetch aggregated fields from the table: "RewardRecord"
  """
  RewardRecord_aggregate(
    """
    distinct select on columns
    """
    distinct_on: [RewardRecord_select_column!]

    """
    limit the number of rows returned
    """
    limit: Int

    """
    skip the first n rows. Use only with order_by
    """
    offset: Int

    """
    sort the rows by one or more columns
    """
    order_by: [RewardRecord_order_by!]

    """
    filter the rows returned
    """
    where: RewardRecord_bool_exp
  ): RewardRecord_aggregate!

  """
  fetch data from the table: "RewardRecord" using primary key columns
  """
  RewardRecord_by_pk(id: Int!): RewardRecord
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}
